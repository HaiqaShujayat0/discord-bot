This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
database/__init__.py
database/connection.py
database/init_db.py
database/models.py
README.md
requirements.txt
src/__init__.py
src/config.py
src/main.py
src/services/__int__.py
src/services/buffer_service.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Virtual Environment
venv/

# Environment Variables (secrets)
.env

# Python cache
__pycache__/
*.pyc

# IDE folders
.vscode/
.idea/
</file>

<file path="database/__init__.py">

</file>

<file path="README.md">

</file>

<file path="src/__init__.py">

</file>

<file path="src/config.py">
import os
from dotenv import load_dotenv

# .env file load karo
load_dotenv()

# Database URL
DATABASE_URL = os.getenv("DATABASE_URL")

# Discord Bot Token  
DISCORD_TOKEN = os.getenv("DISCORD_BOT_TOKEN")

if not DATABASE_URL:
    raise ValueError("DATABASE_URL not found in .env file!")

if not DISCORD_TOKEN:
    raise ValueError("DISCORD_BOT_TOKEN not found in .env file!")

# Test print (baad mein remove karenge)
print("‚úÖ Config loaded successfully!")
print(f"Database URL starts with: {DATABASE_URL[:20]}...")
</file>

<file path="src/services/__int__.py">

</file>

<file path="database/connection.py">
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
import sys
sys.path.append('..')  
from src.config import DATABASE_URL

# Create synchronous engine
engine = create_engine(DATABASE_URL, echo=False)

# Session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class for models
Base = declarative_base()
</file>

<file path="database/init_db.py">
import asyncio
from database.connection import engine, Base
from database.models import Message

async def create_tables():
    """Create all tables asynchronously"""
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    print("‚úÖ Tables created successfully")    

async def drop_tables():
    """Drop all tables asynchronously"""
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)
    print("‚úÖ Tables dropped successfully")    

if __name__ == "__main__":
    asyncio.run(create_tables())
</file>

<file path="database/models.py">
from sqlalchemy import Column, BigInteger, String, Text, DateTime, Boolean, JSON, Index
from sqlalchemy.sql import func
from database.connection import Base

class Message(Base):
    __tablename__ = "messages"
    
    message_id = Column(BigInteger, primary_key=True)
    channel_id = Column(BigInteger, nullable=False, index=True)
    guild_id = Column(BigInteger, nullable=False, index=True)
    author_id = Column(BigInteger, nullable=False, index=True)
    author_name = Column(String(100), nullable=False)
    content = Column(Text, nullable=True)
    created_at = Column(DateTime(timezone=True), nullable=False, index=True)
    edited_at = Column(DateTime(timezone=True), nullable=True)
    deleted_at = Column(DateTime(timezone=True), nullable=True)

    is_pinned = Column(Boolean, default=False)
    has_attachments = Column(Boolean, default=False)
    has_embeds = Column(Boolean, default=False)
    reaction_count = Column(BigInteger, default=0)

    # Separate JSON columns for easier querying (clean approach)
    attachments_data = Column(JSON, nullable=True)  # Array of attachment objects
    embeds_data = Column(JSON, nullable=True)  # Array of embed objects
    reactions_data = Column(JSON, nullable=True)  # Array of reaction objects
    raw_data = Column(JSON, nullable=True)  # Full message snapshot for reference
    
    def __repr__(self):
        return f"<Message(message_id={self.message_id}) by {self.author_name}>"

# Add composite indexes for common query patterns
Index('idx_guild_channel_created', Message.guild_id, Message.channel_id, Message.created_at)
Index('idx_guild_author_created', Message.guild_id, Message.author_id, Message.created_at)
</file>

<file path="requirements.txt">
discord.py==2.5.0
SQLAlchemy==2.0.36
psycopg[binary]==3.3.2
asyncpg==0.29.0
python-dotenv==1.0.0
</file>

<file path="src/main.py">
import discord
from discord.ext import commands
import sys

sys.path.append('.')
from services.buffer_service import save_message, update_message, delete_message, get_messages

from discord import app_commands

from config import DISCORD_TOKEN


# Bot setup - intents define 
# Intents what the bot can access 
intents = discord.Intents.default()
intents.message_content = True  # Messages padhne ki permission
intents.guilds = True           # Server info access
intents.members = True          # Member info access

# Bot creation
bot = commands.Bot( command_prefix="!",intents=intents)


@bot.event
async def on_ready():
    
    print(f" Bot is online!")
    print(f" Logged in as: {bot.user.name}")
    print(f" Bot ID: {bot.user.id}")
    print(f" Connected to {len(bot.guilds)} server(s)")
    print("-" * 50)

    #slash commands here syncing comamnds available when bot connects
    
    try:
        synced = await bot.tree.sync()
        print(f"‚úÖ Synced {len(synced)} slash command(s)")
    except Exception as e:
        print(f"‚ùå Sync Failed: {e}")
    
    print("-" * 50)
            
        

@bot.event  #on message event
async def on_message(message):
   
    # ignore if bot itself
    if message.author == bot.user:
        return

    if not message.guild:
        return 
    
    # print msg info 
    print(f" Message from {message.author}: {message.content[:50]}...")
    
    save_message(message)

    
    # Commands process 
    await bot.process_commands(message)

 # update message event
@bot.event
async def on_message_edit(before,after):
    if after.author.bot:
        return

    if not after.guild:
        return

    print(f" Edit : '{before.content[:30]}...''{after.content[:30]}...'")

    update_message(after)


@bot.tree.command(name="list", description="Show all buffered messages")
async def list_messages(interaction: discord.Interaction):
    """
    /list - Database se saari messages dikhao
    """
    # Get guild ID
    guild_id = interaction.guild.id
    
    # Get messages from database
    messages = get_messages(guild_id=guild_id, limit=20)
    
    # If no messages found
    if not messages:
        await interaction.response.send_message(
            "‚ùå No messages found in database!",
            ephemeral=True
        )
        return
    
    # Create embed
    embed = discord.Embed(
        title="üìã Buffered Messages",
        description=f"Found {len(messages)} message(s)",
        color=discord.Color.blue()
    )
    
    # Add each message to embed
    for msg in messages[:10]:
        if msg.content:
            content = msg.content[:100]
        else:
            content = "[No content]"
        
        embed.add_field(
            name=f"üë§ {msg.author_name}",
            value=f"```{content}```",
            inline=False
        )
    
    # Send ephemeral response
    await interaction.response.send_message(embed=embed, ephemeral=True)


@bot.event
async def on_message_delete(message):
    if message.author.bot:
        return

    if not message.guild:
        return 
    print(f" deleted : '{message.content[:30]}...' by {message.author}")
    
    delete_message(message.id)





@bot.command(name="ping")
async def ping(ctx):
   
    await ctx.send("üèì Pong!")


@bot.command(name="hello")
async def hello(ctx):
    await ctx.send(f"Hello {ctx.author.name}!")


@bot.command(name="info")
async def info(ctx):
    server=ctx.guild
    await ctx.send(
        f" Server info \n"
        f"Name: {server.name}\n"
        f"Members:{server.member_count}\n"
        f"Created:{server.created_at.strftime('%Y-%m-%d')}"

    )


# Bot start 
if __name__ == "__main__":
    print("üîÑ Starting Discord Bot...")
    bot.run(DISCORD_TOKEN)
</file>

<file path="src/services/buffer_service.py">
from database.models import Message
from database.connection import SessionLocal
from datetime import datetime



def save_message(discord_message):
    
    db = SessionLocal()
    
    try:
        # Check if message already exists in database
        existing = db.query(Message).filter(
            Message.message_id == discord_message.id
        ).first()
        
        if existing:
            print(f" Message {discord_message.id} already exists, skipping")
            return existing
        
        # Create new message object
        db_message = Message(
            message_id=discord_message.id,
            channel_id=discord_message.channel.id,
            guild_id=discord_message.guild.id,
            author_id=discord_message.author.id,
            author_name=str(discord_message.author),
            content=discord_message.content,
            created_at=discord_message.created_at,
            is_pinned=discord_message.pinned,
            has_attachments=len(discord_message.attachments) > 0,
            has_embeds=len(discord_message.embeds) > 0,
            reaction_count=0,
            raw_data={
                "jump_url": discord_message.jump_url,
                "attachments": [
                    {"id": a.id, "filename": a.filename, "url": a.url}
                    for a in discord_message.attachments
                ],
                "embeds": [e.to_dict() for e in discord_message.embeds]
            }
        )
        
        # Add to session and save to database
        db.add(db_message)
        db.commit()
        print(f" Saved message {discord_message.id}")
        return db_message
        
    except Exception as e:
        print(f" Error  occured while saving: {e}")
        db.rollback()
        return None
    finally:
        db.close()           




def update_message(discord_message):

    db=SessionLocal()

    try:

        existing=db.query(Message).filter(Message.message_id==discord_message.id).first()

        if not existing:
            return save_message(discord_message)

        #update if old
        existing.content=discord_message.content
        existing.edited_at=discord_message.edited_at
        existing.is_pinned=discord_message.pinned
        existing.has_attachments=len(discord_message.attachments)>0
        existing.has_embeds=len(discord_message.embeds)>0

        db.commit()
        print(f" Updated message {discord_message.id}")
        return existing
        

    except Exception as e :
        print(f"error while updating the message")
        db.rollback()
        return None

    finally:
        db.close()
        
def delete_message(message_id):
    db=SessionLocal()

    try:
        existing=db.query(Message).filter(Message.message_id==message_id).first()
        if not existing:
            print(f" message {message_id}not found in database")
            return False

        db.delete(existing)
        db.commit()
        print(f"permanently deleted message {message_id}")
        return True

    except Exception as e:
        print(f"error deleting: {e}")
        db.rollback()
        return None
    finally:
        db.close()

def get_messages(guild_id=None,channel_id=None,author_id=None,from_date=None,to_date=None,has_attachments=None,limit=20):

    db=SessionLocal()

    try:
        query=db.query(Message).filter(
            Message.guild_id==guild_id,
            Message.deleted_at==None #acive msg not deleted 
        )
    
        if channel_id:
            query=query.filter(Message.channel_id==channel_id)

        if author_id:
            query=query.filter(Message.author_id==author_id)

        if from_date:
            query=query.filter(Message.created_at>=from_date)

        if to_date: 
            query=query.filter(Message.created_at<=to_date)

        if has_attachments:
            query=query.filter(Message.has_attachments==True)


        messages=query.order_by(Message.created_at.desc()).limit(limit).all()

        return messages

    except Exception as e:
        print(f"error getting messages: {e}")
        return []

    finally:
        db.close()
</file>

</files>
